\documentclass{report}
	\title{WorldEditArt}
	\date{2017-07-20}
	\author{SOFe}

\usepackage{hyperref}
\usepackage{xr-hyper}


\def \code #1{\texttt{#1}}
\def \sup #1{\textsuperscript{#1}}

\begin{document}
	\Css{
		body {
			margin: 10px auto;
			max-width: 1000px;
		}
	}

	\maketitle
	\tableofcontents

	\begin{abstract}
		This proposal describes a world edit plugin largely based on features originally intended in WorldEditArt,
		along with some new ideas.
	\end{abstract}

	\part{Plugin mechanism}
		\chapter{Builder sessions}
			Users of this plugin should be managed in "builder sessions" with individual access information. Builder
			sessions can be created in three modes, namely:
			\paragraph{Implicit Mode}
				Players with a certain permission will start a builder session upon joining a game. The session's permission
				and location will be synchronized with the player.
			\paragraph{Explicit Mode}
				Players with a certain permission will start a builder session upon typing a command. The session's
				permission and location will be synchronized with the player, and can be closed with a command. The command
				may be locked with a private password (similar to the \texttt{sudo} Linux command) or global password
				(similar to the \texttt{su} Linux command) for additional protection.
			\paragraph{Minion Mode}
				Command senders with a certain permission (especially non-in-game senders like console) can create minion
				builder sessions upon typing a command. The session's permission and location will be controlled by the
				command sender.
			Each builder session has an allocated amount of resources; this allocation may affect the rate of world-editing
			operations to maximize server performance.

			For implicit and explicit modes, the builder session's position and orientation is synchronized with the
			player. The position uses the block that \textbf{the player's feet stand in}.
			\begin{itemize}
				\item If the player is floating on a lake of liquid, the highest level of the liquid is used.
				\item If the player is standing on a full block (or the part of the block with full height, e.g. an upper slab, the upper step of a stair block), the \emph{air block above} the full block is used.
				\item If the player is standing on an incomplete block (e.g. a lower slab, a chest block, an open-upwards trapdoor), the block itself is used.
			\end{itemize}

		\chapter{The core world editing chain}
			\begin{itemize}
				\item Selection
				\item Block Iterator
				\item Block Changer
				\item Cassette
				\item User History
				\item Load Synchronizer
			\end{itemize}

			\section{Selection and block iterator}
				A selection refers to a 3D shape. A selection can be created by various methods as described in the
				\hyperref[sec:shape-selection]{Shape Selection} section.

				By default, all commands only affect the selection named "default". Builder sessions may also create
				other selections, identified by case-insensitive names. The selections should be discarded upon closing
				a builder session (e.g. when a player quits).

				A selection should provide an iterator providing a unique stream of blocks within the selection, or
				blocks on the margin of the selection at a defined padding (inside the border) and margin (outside the
				border).

			\section{Block changer}
				A block changer is an interface that accepts a Block argument and returns another Block argument,
				determining the new block to set.

				Four implementations of block changer are proposed:
				\paragraph{Simple block changer} The blocks are always set to the specified block type.
				\paragraph{Repeating block changer} A list of block types is provided by the user, and the blocks are
				returned in a loop. For example, if the user specifies \texttt{1 glowstone, 2 glass, 3 stone, 1 lantern},
				the first block set is a glowstone, the next two are glass, etc. This loop repeats at the 9\sup{th}
				block. This is useful for generating patterns in a rectangle or a cuboid, but the direction is undefined.
				\paragraph{Random list block changer} A list of block types is provided by the user. Each block is set
				to one of the block types in the list randomly selected.
				\paragraph{Weighted random list block changer} Same as random list block changer, except that the block
				types have different probability of being selected.

			\section{Clipboard chain}
				An alternative chain is \texttt{Clipboard -> Cassette -> User History -> Load Synchronizer}, where the
				clipboard provides both the block iterator and the block changer. More details will be described in the
				\hyperref[sec:clipboard]{Clipboar} section.

			\section{Cassette}
				A cassette is a section of server memory, or a temporary file on the hard disk (if greater than 10MB),
				storing an ordered list of blocks changed in an operation. It can be re-executed in forward or backward
				order to redo/undo the operation.

			\section{User history}
				A user history manages an "undo stack" and a "redo stack", each holding an ordered list of cassettes.
				When the user requests to undo or redo, a cassette from one stack will be moved to the other stack, and
				pass a reference to the cassette to the load synchronizer.

			\section{Load synchronizer}
				The load synchronizer manages chunk locking and cassette operation queuing. Before starting an
				operation, it determines whether the operation should be executed synchronously or asynchronously and
				stores the chunks (identifiers only) affected by the cassette to manage locking. \emph{Cassette
				operations owned by the same builder session will be executed one by one, but cassette operations owned
				by different builder sessions are executed orderlessly.}

				If the selection shape supports reporting the maximum number of blocks changed per chunk, it would
				determine whether to use the synchronous strategy (updating a few blocks every tick) or the
				asynchronous strategy (lock the chunks, pass all parameters to an AsyncTask, modify them on the other
				thread and send the whole chunks).

			\section{User interface}
				While the chain consists of five components, the user only needs to make two inputs, and only look at
				the final user history.

				A builder session first creates a selection using specific means (e.g. wands, commands, etc.). After
				confirming the selection, the user can execute a manipulation command, e.g. \texttt{//set},
				\texttt{//replace}, etc. This will trigger the block iterator from the selection and instantiate a
				block changer from the manipulation command's arguments. A cassette will be inserted into the user
				history, and the user history shall pull data from block iterator and block changer into the cassette
				for execution.

				If the load synchronizer contains cassettes used by the user, it should show a progress bar on the
				user's screen (tips for players, periodic logger messages (at a lower frequency) for console).

		\chapter{Shape selection}
			The geometric logic is implemented in \textit{libgeom}, while the UI logic is implemented in this plugin.

			A \emph{wand} refers to a combination of an item and an action; left-clicking with an emerald and
			right-clicking with an emerald are considered as two different wands. The clicked block is known as the
			\textit{this} position.

			A wand can be virtually used using a command. For example, the command \texttt{//pos1} is equivalent to
			clicking the \texttt{pos1} wand at the block that the builder session stands in.

			\section{Cuboid}
				\subsection{Definition} A cuboid is always aligned to the XYZ coordinate system.
				\subsection{Parameters} Two points named \texttt{pos1} and \texttt{pos2}. The smallest cuboid
				inscribing both points is selected.
				\subsection{Creation}
					\paragraph{Explicit selection} Execute the wands \texttt{pos1} and \texttt{pos2} to select the two
					positions separately. Executing again manipulates the selection.
					\paragraph{\texttt{shoot} command} \texttt{//cuboid shoot <distance>} selects the \textit{this}
					position as \texttt{pos1}, then shoots a ray along the \textit{this} orientation for a specified length to
					obtain \texttt{pos2}.
					\paragraph{\texttt{grow} command} \texttt{//cuboid grow <+x> [-x] <+y> [-y] <+z> [-z]} modifies the
					current cuboid selection by extending the cuboid on the specified sides. \texttt{pos1} and \texttt{pos2}
					points might be flipped.

			\section{Circular frustum}
				\subsection{Definition} A circular frustum is very flexible. It is the generalization of:
					\begin{itemize}
						\item \href{http://mathworld.wolfram.com/Cylinder.html}{Cylinders}
						\item \href{http://mathworld.wolfram.com/Cone.html}{Cones}
						\item \href{http://mathworld.wolfram.com/ConicalFrustum.html}{Conical frustums}
					\end{itemize}

					Of which, the base shape can be a circle or an ellipse. The base circle may or may not align to the
					XYZ coordinate system. The principal axis (the axis of rotation symmetry) may or may not be
					orthogonal to the XYZ coordinate system, and may or may not be orthogonal to the base shape.
					However, the top shape (for cylinders and conical frustums) must be parallel to the base shape.
				\subsection{Parameters} Despite the great flexibility, there are no conditional parameters. The shape
				is always only parameterized by a base ellipse and a top ellipse.
					\paragraph{Base shape} The base ellipse is defined by a center point \texttt{baseCenter} (a
					position vector), axis 1 \texttt{baseAxis1} (a relative vector from the center to one of the
					extreme points on the ellipse) and axis 2 \texttt{baseAxis2} (a relative vector orthogonal to
					\texttt{baseAxis1} to represent the other elliptic axis).
					\paragraph{Top shape} The top shape must be a stretched projection of the base shape. That is, the
					top shape has parallel axes 1 and 2 to the base shape, but the lengths can be different. Therefore,
					the top shape is defined by the center point \texttt{topCenter}, length of axis 1
					\texttt{topLength1} and length of axis 2 \texttt{topLength2}.

	\end{document}
